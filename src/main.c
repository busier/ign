/*
		------------------------------------------
         Контроллер зажигания ver.0.1.02 6.10.2015
  		------------------------------------------
   Автор: DRY  thehaze@ukr.net (ɔ)
   Распространяется в надежде на то, что он будет полезен,
   но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ; даже без гарантий КОММЕРЧЕСКОЙ
   ЦЕННОСТИ и/или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ.
*/

#include "stm32f10x.h"

/* Переменные:
_capture_1 - захваченное значение счетчика при первом импульсе
_capture_2 - захваченное значение счетчика при втором импульсе
_period - количество тактовых импульсов между двумя фронтами сигналов
_n - дополнительная переменная, состояние которой определяет первый
	 или второй импульс (а точнее, четный или нечетный) поступил на вход.
	 В зависимости от ее содержимого чтение регистра производится в
	 переменную capture_1 или capture_2
_angle - таблица углов зажигания ( а точнее, задержка от ВМТ+90, т.е. от метки на распредвале */
uint16_t _period, _capture_1, _capture_2;
volatile uint8_t n = 0x00;
int _angle[15] = {52, 26, 16, 11, 8.26, 6.33, 5.14, 4.41, 3.92, 3.53, 3.21, 2.94, 2.71, 2.52, 2.35};

void Init_All(void)  //Инициализация периферии
{
  /*Инициализация системы тактирования от внешнего кварца*/
  RCC->CR|=RCC_CR_HSEON; //Включить генератор HSE.
  while (!(RCC->CR & RCC_CR_HSERDY)) {}; //Ожидание готовности HSE.
  RCC->CFGR &=~((RCC_CFGR_PLLSRC|RCC_CFGR_PLLXTPRE|RCC_CFGR_PLLMULL)); //Предочистка.
  RCC->CFGR|=RCC_CFGR_PLLSRC_HSE; //Тактировать PLL от HSE (8 MHz).
  RCC->CFGR|=RCC_CFGR_PLLMULL3; //Умножать частоту на 3 (8*3=24 MHz).
  RCC->CR |= RCC_CR_PLLON; //Запустить PLL.
  while ((RCC->CR & RCC_CR_PLLRDY)==0) {} //Ожидание готовности PLL.
  RCC->CFGR &=~RCC_CFGR_SW; //Очистить биты SW0, SW1.
  RCC->CFGR |= RCC_CFGR_SW_PLL; //Тактирование с выхода PLL.
  while ((RCC->CFGR&RCC_CFGR_SWS)!=0x08) {} //Ожидание переключения на PLL.

  /*Инициализация порта A для выхода на драйвер.
  Вывод PA1 настраивается для работы с выходом TIM2_CH2*/
  RCC->APB2ENR |= (RCC_APB2ENR_IOPAEN); //Тактирование порта A
  GPIOA->CRL |= GPIO_CRL_MODE1; //Максимальная скорость порта = 50 MHz
  GPIOA->CRL &= ~GPIO_CRL_CNF1; //Очистка бит CNF[1:0] для PA1 (поскольку после сброса задан режим "Input Floating")
  GPIOA->CRL |= GPIO_CRL_CNF1_1; //Режим выхода Push-Pull в Alternative Function Mode

  /* Инициализация порта C для управления светодиодом */
  RCC->APB2ENR |= RCC_APB2ENR_IOPCEN; //Разрешаем тактирование шины порта С
  GPIOC->CRH |= GPIO_CRH_MODE13; //Максимальная скорость порта = 50 MHz
  GPIOC->CRH &= ~GPIO_CRH_CNF13;//Очистка бит CNF[1:0] для PC13. Режим Push-Pull

  /* Инициализация таймера TIM2 для формирования прерывания */
  RCC->APB1ENR |= RCC_APB1ENR_TIM2EN; //Тактирование таймера TIM2
  TIM2->CR1 |= TIM_CR1_CEN|TIM_CR1_OPM;    //Включаем формирование одиночного импульса
  TIM2->PSC = 500; //Настройка предделителя таймера (менять угол)
  TIM2->ARR = 1200; //Загружаем число миллисекунд в регистр автоперезагрузки
  TIM2->CCR2 = 1000; // Загружаем счетчик
  TIM2->CCER |= TIM_CCER_CC2E; //Разрешаем выход канала 2
  TIM2->CCMR1 |= (TIM_CCMR1_OC2M_2 | TIM_CCMR1_OC2M_1); //Режим сравнения

  /* Инициализация таймера TIM3.
	Для измерения периода входного сигнала используется канал 1 (TIM3_CH1) */
  RCC->APB1ENR |= RCC_APB1ENR_TIM3EN; //Включаем тактирование TIM3
  TIM3->CCMR1 |= TIM_CCMR1_CC1S_0; //Выбор активного входа. Записываем "01" в биты CC1S - связываем регистр TIM3_CCR1 со входом TI1
  TIM3->CCMR1 |= (TIM_CCMR1_IC1F_0 | TIM_CCMR1_IC1F_1); //Выбор длительнотси действия фильтра - 8 тактов. IC1F = 0011.
  TIM3->CCER &= ~TIM_CCER_CC1P; //По переднему фронту - положительный перепад импульса
  TIM3->CCMR1 &= ~TIM_CCMR1_IC1PSC; //Предделитель отключен
  TIM3->CCER |= TIM_CCER_CC1E; //Разрешен захват значения счетчика в регистр TIM3_CCR1
  TIM3->DIER |= TIM_DIER_CC1IE; //Разрешена генерация прерывания при захвате
  TIM3->CR1 |= TIM_CR1_CEN; //Запускаем счет таймера

  /* Разрешение прерывания от таймера TIM3 */
  NVIC_EnableIRQ(TIM3_IRQn);
}

void Ignition_angle(void)  //Вычисление угла зажигания
{
  GPIOC->ODR ^= GPIO_ODR_ODR13; //Моргаем светодиодом
  if(_period < 60700) // Проверяем обороты двигателя и после 3K RPM увеличиваем время задержки
	 {
		TIM2->PSC = 1500; //Настройка предделителя таймера
	 }
  else
	 {
		TIM2->PSC = (_period / 100); //Настройка предделителя таймера ## Уточнить закон изменения угла ##
	 }
	TIM2->CR1 |= TIM_CR1_CEN; //Старт счета таймера TIM2
}

void TIM3_IRQHandler(void)  //Обработка прерывания по таймеру TIM3
{
  TIM3->SR &= ~TIM_SR_UIF; //Сбрасываем бит вызова прерывания.
  if(!n)
     {
      _capture_1 = TIM3->CCR1;
      n = ~n;
      Ignition_angle();
     }
  else
     {
      _capture_2 = TIM3->CCR1;
      _period = _capture_2 - _capture_1;
      n = ~n;
      Ignition_angle();
     }
}

int main()
{
  Init_All();

  while(1);
     {
     }
}
